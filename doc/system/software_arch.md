# Описание архитектуры #

Вся схема разбита на 5 [главных](#Главные_задачи) задач, 2 [побочные](#Побочные_задачи) и 2 [бинарных семафора](#Бинарные_семафоры).



## <a name="Главные_задачи">Главные задачи</a> ##

### 1.TaskUARTGetData ###


В этой задаче происходит прием данных из **UART** и запись в очередь посредством использования функции FreeRTOS

	osMessagePut(RX_Queue, UART_data, timeout);

<a name="Очередь">Сама</a> очередь постороена по принципу FIFO, что позволяет не потерять новые данные, пришедшие с UART'а. 

### 2.TaskComputeCommand ###


В этой задаче данные из очереди отправляются в [парсер](https://github.com/AFAlexandrov/command-parser), используя функции FreeRTOS

	parse(osMessageGet(RX_Queue, 100));

В результате анализа команды собирается структура, состоящая из 3 типов данных, к которой уже другие задачи будут получать доступ для своей дальнейшей работы:


1.	Параметр

Найденный параметр **не обрабатывается** самим парсером, а заносится в свое поле, чтобы в последствие в задаче **TaskActionCommand**, блок [постобработки](#Posprocessing) и преобразовал его в значение для дальнейшего использования. 

2.	Действие

Найденное действие готово для выполнения без последующей обработки и заполняется в структуру.  

3.	Ответ

Из команды парсер, также может выделить ответ, который будет отображаться у пользователя в консоли об успешном/не успешном действии или в виде системной информации. 

---
Система может не брать информацию, которую обнаружил в команде парсер. 

Суть этого блока заключается в том, что вся информация, найденная парсером, хранится **только после обработки** конкретной команды, а при следующей итерации старый результат будет утерян, так как **все** поля итоговой структуры будут перезаписаны. 

*Возникает потенциальная проблема ввиде того, что во время выполнения действий, может произойти перезапись полей итоговой структуры, а в следствие потеря информации, которая была нужна другой части системы, это может повлечь некорректную работу системы.*

Для предотвращения коллизий были "повешены" [бинарные семафоры](#Бинарные_семафоры).  

### 3.TaskActionCommand ###

Из итоговой структуры, сформированной предыдущей задачей, эта задача считывает 2 поля: **параметр и действие**
 

Действие обработано так, что может быть сразу выполнено. Вообще все действия, которые происходят в системе конкретно с аппаратной частью совершаются из этой задачи или из нее запускаться. Так, например, для вывода информации на экран эта задача заполнит <a name="Структура">*структуру, в которой находятся строки на вывод,*</a> и перейдет в состояние **Blocked** с последующим вызовом [нужной](#sideTaskDisplayPushData) задачи.

А параметр необходимо отправить в блок **Posprocessing**.

#### <a name="Posprocessing">Блок "Posprocessing"</a> #### 

Переданный из парсера параметр необходимо конкретезировать для дальнейшего использования действиями или отправки в ответ. Например, получаения значения напряжения отсечки или типа аккумулятора. 	

Также значения может отправится в задачу, которая формирует ответ для пользователя. 

/*in progress*/

### 4.TaskPreparationResponse  ###

Из итоговой структуры эта задача берет последнее поле : **ответ**

Сам полный пакет для передачи в UART формируется из вышеупомянутого значения и этого ответа и записывается в очередь *на выход*.

	osMessagePut(TX_Queue, compiled_response , 100);

/*in progress*/

### 5.TaskUARTPushData ###

В этой задаче существует заполненная очередь, подобная очереди *на вход* в задаче [**TaskUARTGetData**](#Очередь) и она выгружается в UART.

	HAL_UART_Transmit (&huart,TX_Queue,Size,Timeout);

/*in progress*/


## <a name="Побочные_задачи">Побочные задачи</a> ##

Эти задачи имеют более низкий приоритет по сравнение с [главными](#Главные_задачи), поэтому для их выполнения необходимо переводить вышестоящие по приоритету задачи в состояние **Blocked**, что может произойти различными способами. 

### <a name="sideTaskDisplayPushData">1.sideTaskDisplayPushData</a> ###

1. Задача проанализирует подготовленную заранее [структуру](#Структура) с полями:
	* **Команда** или иной другой текст, находящиеся в первой строчке.
	* **Значение**, которое будет находится во второй строке.
2. В зависимости от тех символов, которые будет выгружены, изменяет текст на экране. 


/*in progress*/

### 2.sideTaskKBGetAction ###

В этой задаче происходит прием данных с клавиатуры таким образом, что нажатия на клавиатуре преобразовываются в этой задаче уже в готовые действия, без подключениях иных блоков. 

Если с клавиатуры ожидается значение, то система **не остается в ожидании**, а периодически обрашивает буфер, для этого значения, находящийся в самой задаче. Таким образом не происходит **повисаний** системы в конкретной задаче. 

/*in progress*/

## <a name="Бинарные_семафоры">Бинарные семафоры</a> ##

Семафоры не дадут выпонятся другому коду, точнее нельзя будет выполнять разбор команды, пока происходит выполнение действия и наоборот.  

### 1.BinSemNoParseGoAction ###

Запрет выполения разбора команды во время действия.

/*in progress*/


### 2.BinSemNoActionGoParse ###

Запрет выполнения действия во время разбора команды.

/*in progress*/

---

Однако другие задачи могут выполнять свои действия, ведь они не влекут потерую данных. Например, задача **TaskPreparationResponse** может из парсера извлечь Response или другие другие задачи взаимодействовать друг с другом. 