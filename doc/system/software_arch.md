# Описание архитектуры #

Вся схема разбита на 5 [главных](#Главные_задачи) задач, 2 [побочные](#Побочные_задачи) и 2 [бинарных семафора](#Бинарные_семафоры).



## <a name="Главные_задачи">Главные задачи</a> ##

### 1.task_uart_receive_data ###


В этой задаче происходит прием данных из **UART** и запись в очередь посредством использования функции FreeRTOS

	osMessagePut(RX_Queue, UART_data, timeout);

<a name="Очередь">Сама</a> очередь постороена по принципу FIFO, что позволяет не потерять новые данные, пришедшие с UART'а. 

### 2.task_extract_command ###


В этой задаче данные из очереди отправляются в [парсер](https://github.com/AFAlexandrov/command-parser), с помощью функции FreeRTOS

	parse(osMessageGet(RX_Queue, 100));

#### Описание ####

После анализа сообщения на наличие команды, данные предоставляемые парсером помещаются в структуру (промежуточный буфер комманд), состоящую из трёх полей (описанных ниже). Далее, задачи, ответственные за выполнение принятой комманды, будут забирать эти данные в порядке очереди по необходимости. При этом система может не использовать информацию, которую обнаружил в команде парсер.

1.	Действие (заранее определено)

Действие - это процедура, зарегистрированная за соответсвтвующей коммандой на этапе кодирования. Для исполняющих задач сохраняется только её адрес для своевременного вызова.

2.	Ответ (заранее определён)

Ответ - это строка, которую можно отправить пользователю в случае успешного выполнения команды. Для исполняющих задач сохраняется только её адрес.

3.	Параметр (не определён)

Параметр - это фрагмент строки, следующий за корректно извлечённой командой (из собщения). Если задача команды в том, чтобы передать какое-либо значение от пользрователя  в программу, это значение можно передать с помощью поля параметр. Однако, задача парсера только в том, чтобы извлечь команду из сообщения, разобрав её на составляющие. При этом ответственность за выполнение команды и корректное использование составляющих лежит на пользователе.

Поэтому найденный параметр **не обрабатывается** самим парсером, а заносится в соответствующее поле, чтобы в дальнейшем пользовательский блок [постобработки](#Posprocessing) в задаче **task_exec_user_action**, преобразовал его в значение удобное для использования.

#### Необходимость использовать семафор ####

Поскольку в область ответственности парсера не входит хранение информации о разобранных сообщениях, задача своевременного забора выходных данных парсера и их сохранение до востребования также ложится на плечи пользователя. Парсер хранит результаты **только ближайшей** обработки сообщения.

Задачи парсера и выполнения действия работают в разных потоках, однако, результаты парсера могут понадобиться во время выполнения действия. Таким образом, если парсер получит новые результаты до того как будут прочтены старые, действие выполнится непредстказуемо.

Для предотвращения коллизий были использованы [бинарные семафоры](#Бинарные_семафоры).

### 3.task_exec_user_action ###

Все действия, являющиеся реакцией на запросы пользователя, включая выполняются в этой задаче.
Задача использует два поля структуры, сформированной предыдущей задачей: **параметр и действие**

Например, для вывода информации на экран эта задача заполнит <a name="Структура">*структуру, в которой находятся строки на вывод,*</a> и перейдет в состояние **Blocked** с последующим вызовом [соответствующей](#sideTaskDisplayPushData) задачи.

Параметр будет отправлен в блок **Posprocessing**.

#### <a name="Posprocessing">Блок "Posprocessing"</a> #### 

Переданный из парсера параметр является фрагментом сырых данных, которые необходимо конкретезировать для дальнейшего использования.

Этот блок занимается преобразованием сырой строки в данные соответствующего задаче вида. А также обработкой ошибок соответствия типу и диапазону полученного значения.

Значение может, например, далее отправится в задачу, которая формирует ответ для пользователя. 

/*in progress*/

### 4.task_create_response ###

Эта задача занимается формированием ответа пользователю.

Пример:
Из итоговой структуры задача берет последнее поле : **ответ**
Дополняет его данными, полученными из аппаратной части или вычислений.
Записывает результат в очередь на передачу для UART.

	osMessagePut(TX_Queue, compiled_response , 100);

/*in progress*/

### 5.task_uart_send_data ###

В этой задаче существует заполненная очередь, подобная очереди *на приём* в задаче [**task_uart_receive_data**](#Очередь) и она выгружается в UART.

	HAL_UART_Transmit (&huart,TX_Queue,Size,Timeout);

/*in progress*/


## <a name="Побочные_задачи">Побочные задачи</a> ##

Эти задачи имеют более низкий приоритет по сравнение с [главными](#Главные_задачи), поэтому для их выполнения необходимо переводить вышестоящие по приоритету задачи в состояние **Blocked**, что может произойти различными способами. 

### <a name="sideTaskDisplayPushData">1.sideTaskDisplayPushData</a> ###

1. Задача проанализирует подготовленную заранее [структуру](#Структура) с полями:
	* **Команда** или иной другой текст, находящиеся в первой строчке.
	* **Значение**, которое будет находится во второй строке.
2. В зависимости от тех символов, которые будет выгружены, изменяет текст на экране. 


/*in progress*/

### 2.task_keyboard_get_action ###

Эта задача транслирует нажатие к

В этой задаче происходит прием данных с клавиатуры таким образом, что нажатия на клавиатуре преобразовываются в этой задаче уже в готовые действия, без подключениях иных блоков. 

Если с клавиатуры ожидается значение, то система **не остается в ожидании**, а периодически обрашивает буфер, для этого значения, находящийся в самой задаче. Таким образом не происходит **повисаний** системы в конкретной задаче. 

/*in progress*/

## <a name="Бинарные_семафоры">Бинарные семафоры</a> ##

Семафоры не дадут выпонятся другому коду, точнее нельзя будет выполнять разбор команды, пока происходит выполнение действия и наоборот.  

### 1.bin_sem_no_parser_go_action ###

Запрет выполения разбора команды во время действия.

/*in progress*/


### 2.bin_sem_no_action_go_parser ###

Запрет выполнения действия во время разбора команды.

/*in progress*/

---

Однако другие задачи могут выполнять свои действия, ведь они не влекут потерую данных. Например, задача **task_create_response** может из парсера извлечь Response или другие другие задачи взаимодействовать друг с другом. 
