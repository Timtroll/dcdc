# Блок Screen #

Блок **Screen** создает выбранный тип экрана, на основе доступных ему данных в памяти, которую ему выделили.

	void scr_constructor_screen(
	uint8_t screen_type,
	uint8_t number_lines,
	char ** screen_name,
	char ** screen_value,
	char ** screen_promt,
	void * screen_obj
	)

## Аргументы ##
*uint8_t screen_type* - может быть два варианта значений

— **0** - главный (main) экран. Нарисовать таблицу.

рисунок 1

— **любое положительное число** - побочный (side) экран

рисунок 2

*uint8_t number_lines*

— Для побочного экрана число всегда равно **трем**! (см. рисунок 1)

— Для главного экрана - это число строк, которые нужно описать. (см. рисунок 2)


*char ** screen_name* 

Указатель на массив константных *строк*.
Имена экранов в нашем случае - это имена параметров, которые будет видеть пользователь: voltage_cutoff, type_charge, quantity_cans и т.д.

*char ** screen_value*

Указатель на массив функций, возвращающих *char\**,  из блока **Sys_info**, информация в котором постоянно обновляется и зависит от  "железной" части.  

*char ** screen_promt*

Аналогичен screen_name. 
Подсказки есть **только** для побочных экранов, ведь они состоят из трех разных частей : Имя-Значение-Подсказка. А гланый экран уже сотоит из пар Имя-Значение, подсказка на этом экране не подразумевается. 

*void * screen_obj*

Указатель на место в памяти, где будет сконструирован экран.

## Общая логика работы ##

### Создание главное экрана ###

* Первый агрумент - 0.
* Второй аргумент - 11.
* Третий, четверый, пятый аргументы - указатели на данные.
* Шестой аргумент - указатель на память.

В конструктор пришёл запрос на создание главного(стартового) экрана. Значит второй аргумент является числом пар **Имя(ключ)-Значение**. Далее формируется  одномерный массив строк, в котором нулевой элемент - это число нуль, как обозначение главного экрана. Первый элемент - это число строк в таблице (точнее, пар Имя-Значение), а со второго элемента начинаются пары Имя-Значение.

То есть второй элемен содержит в себе Имя_1, третий - Значение_1,четвертый - Имя_2, а пятый - Значение_2. Все значение получаются по указателям на имена экранов и значения. 
	
	main_table[4] = screen_name[2];
	main_table[5] = screen_value[2];

Таким образом образуются пары в количестве *number_lines*.    

Вид в памяти:
	
	[0][11][name_screen_1][value_screen_1][name_screen_2][value_screen_2]...[name_screen_11][value_screen_11]

### Создание побочного экрана экрана ###

* Первый агрумент - 7.
* Второй аргумент - 3.
* Третий, четверый, пятый аргументы - указатели на данные.
* Шестой аргумент - указатель на память.

В конструктор пришёл запрос на создание побочного экрана. Значит второй аргумент должен быть равен трём. После чего формируется одномерный массив на 4 элемента. Нулевой содержит в себе значение первого аргумента(число 7), первый - Имя_7, второй -  Значение_7, третий -  Подсказка_7. То есть **screen_type**, помимо того, что является флагом экраном, он в случае побочного экрана, показывает номер экрана, который надо "сконструировать".

Вид в памяти:

	[7][name_screen_7][value_screen_7][promt_screen_7] 