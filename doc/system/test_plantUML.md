


![test_plantUML](http://www.plantuml.com/plantuml/png/SYWkIImgAStDuN9q3l7qzrFGpKbDAz6rKmYE30vnzOttz7FpL-3oTVKBnIO3bIZAJCy0opW7kRhwmKrAoI_F0ug2r72vU0O7-3X6AkX21U2AIWl08ex1eK6kG8aGc4g4gLx1_dxn0Ov1mQv1K5q8EQXYBgwy_99KXPBy0eNyD9YW0fTDSMPLgfMXWHs0BBB9II08el3UKzHI4-AL20d4cAWXoCRT36EK19IuynZD2EcMeTihlBgHzJeZTdGn_KDNFLvz3-_mWWzqS6WHaUoS15zmMccDlLPmWgqssDbb8MXr1OyM3X7kLqSVhIJYe4y8kg50al7r_VHcz32ycio7qz5iT3kPpyulYfuwJo1Qwq8h91pi-nm8TrtOLscZh_OCXwEPGCUQmdl4tWon8573rWqYWlNGDZmIjZoP_7fGz9avVM4zZjg8RP66EUiUEpXgYLtVA9uTbZmkpoPtOo7LdcqcJhf570NXVmAzvHR9ZDho_FFFVqnc91apEWHu1Fv2z2QGduCkSz-Id2XB8WomGAfD8NeYnR03foJebiaQzg0rqQ3JDRn9RgHCjP0f0benWgrjPb7WuGWGKLUzG-aD8J0Pwfp6SVaMlXkjWXt7MHXyprDmdMccqly_mLvMUrrfvuvSub1M5B9WTgQAvjtNIPX29ssLNDhON-mFVpPGbLDPY57aJXwRdGu-3JAU8-596jTxxfviF274yfOxhNQxn6yVJGvQZoP7VianSrTYY6Fprri2ZL8bydtV2ZeFA0z0hK1I-mynFOtafzdlnQ_lhvo3ZhwBOhzlTXnl9YWZahoEn3IktP-1EUrvvLH72DeuFQDkUr7ICM0yUjl9dmTf_Hk6JSWq35kGdeuOkBZY2v2B_1Mx2lOdWID3Pwd0nNKg642nT-KumRi4ook1WyNxCEC8WmDxgN27FIHB36HDVjpJH3_MH3_IH3_KH6_MH6_MH6_LH6_GH3_KHD_JH6_JH3_Mf4pVTAxnr5aJIKOL4DtOy2_dCAuLqp-LGa2t31j_jvi6MCOtmxBC-ok7gsqM-sAQQ82Y13O7Bs2acMbD9f_5lBsyJYiRHRDy9Fr0nZCTbqu73D8QX_6ZsIcqbeDq-CwqPghUHGf9aG-V-MYA95hnt071KuOTmMbSqfSORGtfy6kWP_vz4lmKllKLW6kux6-vs6EZaHaRDoJwhnLJENC5CowNTMoMBWcjcDYdPQKLC3VOs0ICB1AuYAmBslxbqc4Y066b3yIBv3gNlBOjd6wR_r-P9-PnPVM96CtcRC-haNan6L_iPMqhLvdjnL7wjgouVEGTWQ9RhkkQoAacLysLRrWiL3wJolPowSqhLswDti_KRbwPVaVlPAHWd7ugaCWGX-zKujQkShJLzEeh2Wy0Oo86pcv8Jcqf--JKKhwB4vJ2WMJ5eN9oPY2KuCuBO02pvFk6haid-my0)


# Описание внутренней части системы #

/*in progress*/

Представленная схема была создана на основе **UML**-диаграммы классов. В ней представлены *открытые* операции для всех классов и для некоторых классов изображены группы *приватных* атрибутов для обозначения того, чем оперирует блок. 

На схеме изображены 7 классов: [User_action](#USER_ACTION), [System_info](#SYSTEM_INFO), [Measurements](#MEASUREMENTS), 
[Menu](#MENU), [Screen](#SCREEN), [Display](#DISPLAY) и один дополнительный в виде [JSON_Parser](#JSON_PARSER)

Сами классы в совокупности представляют собой ту часть системы, которая назвывается *блок контроля*,а также	 часть по работе с экраном.
Здесь происходят главные действия в виде: 

* Измерения 
* Установка
* Работа с блоком **I/O**

## Классы ##



### <a name="USER_ACTION">User_action</a> ###

Блок **User_Action** является классом, который предоставляет в парсер варианты взаимодействия с системой для корректного анализа поступившей команды. Далее задача, которая производит непосредственно "действия" в системе имеет доступ к реализации объявленных методов и выполняет их в системе. 

* Операции

На схеме изображены не фактические операции, а группы в которые они объединяются по признаку принадлежности к какому-то другому классу, в последствии уже эти методы отправлюятся в *.h файл* и закрепляются в парсере, как готовые строки. 


Блок включает в себя классы: **System_info, Menu, Measurement, Display**; а через них уже может непосредственно производить изменения в системе, получать данные или работать с блоком **I/O**.


### <a name="SYSTEM_INFO">System_info</a> ###

/*in progress*/

Этот блок - место для хранения *стартовых* характеристик, которые позволяют запустить всю систему. Но главное назначение этого класса - это хранить "предельные" параметры которые **должны** быть в системе и которые нельзя нарушать. 


1. Атрибуты

Это и есть стартовые характеристики системы, которые задаются еще на моменте компиляции, позволяющие *запустить* систему. Система должна знать с каким аккумулятором она работает, как его заряжать и тд.

* Тип батареи
* Напряжение отсечки 
* Максимальный ток потребления
* Формат зарядки
* и т.д.

Но сами атрибуты скрыты и доступ к ним осуществаяется посредством использования операций.

2. Операции


В операциях выделяются две группы работы.	

* Получить значение - **get**

		sys_info_get_voltage_cutoff()

* Установить/выбрать значение - **set**

		sys_info_set_type_battery()


### <a name="MEASUREMENTS">Measurements</a> ###

Сам блок по большей части представляет собой закрытую систему, где происходят измерения на АЦП и датчиках тока, и в отличии от **System_info**, этот блок хранит **реальные** данные о системе, которые постоянно обновляются, посредством использования ресурсов не подконтрольных системе. Данные хранятся в удобном для **Measurements** виде, разделяя на 3 группы атрибутов:

1. Voltage  
2. Current
3. Other

Но по требованию системы, использующей открытый интерфейс, например

	meas_voltage_gen()
	meas_current_charger()
	meas_contact_resistance()

Блок переконвертирует свои данные в нужный формат и предоставит требующему блоку. 

### <a name="MENU">Menu</a> ###

Класс **Menu** - это астрактный способ представлять переходы в системе(навигацию) и хранить данные для блока **I/O**. В нем методы - это варианты взаимодействия с экраном, например 
	
		screen_switch_right()

Блок создает двусвязный список из абстрактных экранов, использую конструктор блока **Screen**, и заполняет информацией из блока **Sys_info**. А методы позволяют переходить по этому списку, как пользователь перемещался бы по меню реальной системы, а также заносить/получать информацию. Также этот блок помогает другому классу - **Display** ориентироваться в экранах и корректно заполнять данные на отправку в блок **I/O**, посредством целого каскада запросов данных. 

Блок включает в себя класс: **Screen**.

### <a name="SCREEN">Screen</a> ###

Класс **Screen** описывает полную работу с "экранами", а точнее их создание, редактирование, уничтожение. Полученными экранами в дальнейшем оперирует астрактное **Menu**.

Атрибуты максимульно были упрощены и бОльшая часть обработки экрана ложиться на блок **I/O**, где в зависимости от разметки выставляются конкретные значения шрифтов, размеров таблицы и тд.  

### <a name="DISPLAY">Display</a> ###


Класс **Display** - это звено между системой с ее **Menu** и реальным экраном. То есть этот класс собирает из **Menu**, опрашивая какой следующий экран и от этого выстраивается целый каскад запросов "ключ-значение", готовую информацию для вывода на экран и переводит ее в удобный для транспортировки формат, и отправляет уже в блок **I/O**. 

Пришедший JSON-запрос в **Action**, он сам обработать не может, поэтому уже блок **Display** работает с парсером и в зависимости от того, что было в строке может обращаться к блоку **Menu**, для построения экрана.

Все команды максимально унифицированы, отсюда и получается главная особенность этого блока. Все экраны, которые он формирует на отправку в блок **I/O** или на компьютер, будут выглядеть одинаково. Уже конечная точка будет для себя выстраивать экран в зависимости от пришедших данных.  

### <a name="JSON_PARSER">JSON_Parser</a> ###
 
Этот небольшой класс разбирает JSON строку, которая приходит в блок **Action** после чего он передать ее в парсер, и результат (числа, текст и тд.) уже использует **Display**.  